### Eclipse Workspace Patch 1.0
#P Rhino
Index: src/org/mozilla/javascript/MemberBox.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/MemberBox.java,v
retrieving revision 1.19
diff -u -r1.19 MemberBox.java
--- src/org/mozilla/javascript/MemberBox.java	26 Jun 2008 13:57:11 -0000	1.19
+++ src/org/mozilla/javascript/MemberBox.java	7 Jan 2010 00:51:15 -0000
@@ -52,7 +52,7 @@
  * @author Igor Bukanov
  */
 
-final class MemberBox implements Serializable
+public final class MemberBox implements Serializable
 {
     static final long serialVersionUID = 6358550398665688245L;
 
@@ -62,12 +62,13 @@
     transient boolean vararg;
 
 
-    MemberBox(Method method)
+
+    public MemberBox(Method method)
     {
         init(method);
     }
 
-    MemberBox(Constructor<?> constructor)
+    public MemberBox(Constructor<?> constructor)
     {
         init(constructor);
     }
@@ -86,47 +87,47 @@
         this.vararg = VMBridge.instance.isVarArgs(constructor);
     }
 
-    Method method()
+    public Method method()
     {
         return (Method)memberObject;
     }
 
-    Constructor<?> ctor()
+    public Constructor<?> ctor()
     {
         return (Constructor<?>)memberObject;
     }
 
-    Member member()
+    public Member member()
     {
         return memberObject;
     }
 
-    boolean isMethod()
+    public boolean isMethod()
     {
         return memberObject instanceof Method;
     }
 
-    boolean isCtor()
+    public boolean isCtor()
     {
         return memberObject instanceof Constructor;
     }
 
-    boolean isStatic()
+    public boolean isStatic()
     {
         return Modifier.isStatic(memberObject.getModifiers());
     }
 
-    String getName()
+    public String getName()
     {
         return memberObject.getName();
     }
 
-    Class<?> getDeclaringClass()
+    public Class<?> getDeclaringClass()
     {
         return memberObject.getDeclaringClass();
     }
 
-    String toJavaDeclaration()
+    public String toJavaDeclaration()
     {
         StringBuffer sb = new StringBuffer();
         if (isMethod()) {
@@ -153,7 +154,7 @@
         return memberObject.toString();
     }
 
-    Object invoke(Object target, Object[] args)
+    public Object invoke(Object target, Object[] args)
     {
         Method method = method();
         try {
@@ -186,7 +187,7 @@
         }
     }
 
-    Object newInstance(Object[] args)
+    public Object newInstance(Object[] args)
     {
         Constructor<?> ctor = ctor();
         try {
Index: src/org/mozilla/javascript/ScriptRuntime.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptRuntime.java,v
retrieving revision 1.322
diff -u -r1.322 ScriptRuntime.java
--- src/org/mozilla/javascript/ScriptRuntime.java	21 Sep 2009 13:32:34 -0000	1.322
+++ src/org/mozilla/javascript/ScriptRuntime.java	7 Jan 2010 00:51:19 -0000
@@ -3355,6 +3355,10 @@
 
             Scriptable errorObject = cx.newObject(scope, errorName, args);
             ScriptableObject.putProperty(errorObject, "name", errorName);
+            // Lehni:
+            // Add java exception to the error object so we can do stack traces
+            // from the JavaScript side
+            ScriptableObject.putProperty(errorObject, "exception", re);
 
             if (javaException != null && isVisible(cx, javaException)) {
                 Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException,
Index: src/org/mozilla/javascript/JavaMembers.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/JavaMembers.java,v
retrieving revision 1.80
diff -u -r1.80 JavaMembers.java
--- src/org/mozilla/javascript/JavaMembers.java	6 Jun 2009 14:11:24 -0000	1.80
+++ src/org/mozilla/javascript/JavaMembers.java	7 Jan 2010 00:51:15 -0000
@@ -52,9 +52,9 @@
  * @see NativeJavaObject
  * @see NativeJavaClass
  */
-class JavaMembers
+public class JavaMembers
 {
-    JavaMembers(Scriptable scope, Class<?> cl)
+    public JavaMembers(Scriptable scope, Class<?> cl)
     {
         this(scope, cl, false);
     }
@@ -79,7 +79,7 @@
         }
     }
 
-    boolean has(String name, boolean isStatic)
+    public boolean has(String name, boolean isStatic)
     {
         Map<String,Object> ht = isStatic ? staticMembers : members;
         Object obj = ht.get(name);
@@ -89,7 +89,7 @@
         return findExplicitFunction(name, isStatic) != null;
     }
 
-    Object get(Scriptable scope, String name, Object javaObject,
+    public Object get(Scriptable scope, String name, Object javaObject,
                boolean isStatic)
     {
         Map<String,Object> ht = isStatic ? staticMembers : members;
@@ -99,8 +99,7 @@
             member = staticMembers.get(name);
         }
         if (member == null) {
-            member = this.getExplicitFunction(scope, name,
-                                              javaObject, isStatic);
+            member = this.getExplicitFunction(scope, name, isStatic);
             if (member == null)
                 return Scriptable.NOT_FOUND;
         }
@@ -130,7 +129,7 @@
         return cx.getWrapFactory().wrap(cx, scope, rval, type);
     }
 
-    void put(Scriptable scope, String name, Object javaObject,
+    public void put(Scriptable scope, String name, Object javaObject,
              Object value, boolean isStatic)
     {
         Map<String,Object> ht = isStatic ? staticMembers : members;
@@ -195,7 +194,7 @@
         }
     }
 
-    Object[] getIds(boolean isStatic)
+    public Object[] getIds(boolean isStatic)
     {
         Map<String,Object> map = isStatic ? staticMembers : members;
         return map.keySet().toArray(new Object[map.size()]);
@@ -285,8 +284,7 @@
         return null;
     }
 
-    private Object getExplicitFunction(Scriptable scope, String name,
-                                       Object javaObject, boolean isStatic)
+    private Object getExplicitFunction(Scriptable scope, String name, boolean isStatic)
     {
         Map<String,Object> ht = isStatic ? staticMembers : members;
         Object member = null;
@@ -487,13 +485,59 @@
                     methodBoxes[0] = new MemberBox((Method)value);
                 } else {
                     ObjArray overloadedMethods = (ObjArray)value;
-                    int N = overloadedMethods.size();
-                    if (N < 2) Kit.codeBug();
-                    methodBoxes = new MemberBox[N];
-                    for (int i = 0; i != N; ++i) {
-                        Method method = (Method)overloadedMethods.get(i);
-                        methodBoxes[i] = new MemberBox(method);
+                    // Lehni:
+                    // Filter out synthetic bridge methods, generated for
+                    // generics (see ClassFileFormat-Java5.pdf).
+                    // These methods may pretend to take Objects but then
+                    // cast to the type defined by erasures, leading to
+                    // Rhino preferring the wrong versions and then
+                    // throwing a ClassCastException.
+                    // Do not filter in discoverAccessibleMethods since
+                    // it is easier to discover synthetic-only methods
+                    // that should still be added, since methods are
+                    // grouped by name here. This happens for example
+                    // in various classes of the Java 1.6 Doclet API,
+                    // but not in 1.5. No idea where these modifiers
+                    // come from there.
+                    int count = overloadedMethods.size();
+                    if (count < 2) Kit.codeBug();
+                    ObjArray validMethods = new ObjArray();
+                    for (int i = 0; i < count; i++) {
+                        Method method = (Method) overloadedMethods.get(i);
+                        if (method.isBridge() && method.isSynthetic()) {
+                            // See if there is another method with a similar signature.
+                            // If there is, do not add this one, otherwise keep it
+                            boolean overrides = false;
+                            Class<?> returnType = method.getReturnType();
+                            Class<?>[] types = method.getParameterTypes();
+                            for (int j = 0; j < count && !overrides; j++) {
+                                if (j != i) {
+                                    Method otherMethod = (Method) overloadedMethods.get(j);
+                                    overrides = returnType.isAssignableFrom(otherMethod.getReturnType());
+                                    if (overrides) {
+                                        Class<?>[] otherTypes = otherMethod.getParameterTypes();
+                                        if (types.length == otherTypes.length)
+                                            for (int k = 0; k < types.length && overrides; k++)
+                                                overrides = types[k].isAssignableFrom(otherTypes[k]);
+                                    }
+                                }
+                            }
+                            // Add it if it does not override another real method
+                            if (!overrides)
+                                validMethods.add(method);
+                        } else {
+                            validMethods.add(method);
+                        }
                     }
+                    // If they are all synthetic bridge methods, add them still:
+                    if (validMethods.size() == 0) {
+                        validMethods = overloadedMethods;
+                    } else {
+                        count = validMethods.size();
+                    }
+                    methodBoxes = new MemberBox[count];
+                    for (int i = 0; i != count; ++i)
+                        methodBoxes[i] = new MemberBox((Method) validMethods.get(i));
                 }
                 NativeJavaMethod fun = new NativeJavaMethod(methodBoxes);
                 if (scope != null) {
@@ -559,6 +603,9 @@
             }
         }
 
+        Context cx = Context.getContext();
+        WrapFactory wrapFactory = cx.getWrapFactory();
+
         // Create bean properties from corresponding get/set methods first for
         // static members and then for instance members
         for (int tableCursor = 0; tableCursor != 2; ++tableCursor) {
@@ -566,6 +613,8 @@
             Map<String,Object> ht = isStatic ? staticMembers : members;
 
             Map<String,BeanProperty> toAdd = new HashMap<String,BeanProperty>();
+            // Lehni:
+            ArrayList<BeanProperty> toRemove = new ArrayList<BeanProperty>();
 
             // Now, For each member, make "bean" properties.
             for (String name: ht.keySet()) {
@@ -646,10 +695,36 @@
                             }
                         }
                     }
-                    // Make the property.
-                    BeanProperty bp = new BeanProperty(getter, setter,
-                                                       setters);
-                    toAdd.put(beanPropertyName, bp);
+                    // Lehni:
+                    // Make sure we actually found a getter / setter
+                    // TODO: Submit this to Rhino
+                    if (getter != null || setter != null) {
+                        // Make the property.
+                        // Lehni:
+                        // Do not produce bean properties for read-only
+                        // is-getters, since the convention is to use
+                        // is##NAME##() as a method instead.
+                        if (wrapFactory.shouldAddBean(cl, isStatic, getter, setter)) {
+                            BeanProperty bp = new BeanProperty(getter, setter,
+                                setters);
+                            toAdd.put(beanPropertyName, bp);
+                            // Lehni:
+                            // remove getters / setters from ht / methods ?
+                            if (wrapFactory.shouldRemoveGetterSetter(cl, isStatic,
+                                getter, setter)) {
+                                toRemove.add(bp);
+                                // If this bean property has a reference to the setters method
+                                // we need to clone it since we're going to remove
+                                // fields from the main function in ht.
+                                if (bp.setters != null) {
+                                    bp.setters = new NativeJavaMethod(bp.setters.methods);
+                                    if (scope != null) {
+                                        ScriptRuntime.setFunctionProtoAndParent(bp.setters, scope);
+                                    }
+                                }
+                            }
+                        }
+                    }
                 }
             }
 
@@ -658,6 +733,27 @@
                 Object value = toAdd.get(key);
                 ht.put(key, value);
             }
+            // Lehni:
+            // Remove the marked getters / setters
+            for (BeanProperty bp : toRemove) {
+                if (bp.getter != null)
+                    removeMethod(ht, bp.getter);
+                if (bp.setters == null) {
+                    if (bp.setter != null)
+                        removeMethod(ht, bp.setter);
+                } else {
+                    // Scan through setters and find the ones
+                    // that are really used
+                    // as setters, remove only these.
+                    ArrayList<MemberBox> removeSetters = new ArrayList<MemberBox>();
+                    for (MemberBox member : bp.setters.methods) {
+                        if (member.method().getReturnType() == Void.TYPE
+                            && member.argTypes.length == 1)
+                            removeSetters.add(member);
+                    }
+                    removeMethods(ht, removeSetters);
+                }
+            }
         }
 
         // Reflect constructors
@@ -668,6 +764,38 @@
         }
     }
 
+    private void removeMethod(Map<String, Object> ht, MemberBox member)
+    {
+        removeMethods(ht, Arrays.asList(new MemberBox[] { member }));
+    }
+
+    private void removeMethods(Map<String, Object> ht, List<MemberBox> members)
+    {
+        if (members.size() > 0) {
+            String name = members.get(0).getName();
+            NativeJavaMethod method = (NativeJavaMethod) ht.get(name);
+            int length = method.methods.length - members.size();
+            if (length == 0) {
+                // Remove this one altogether
+                ht.remove(name);
+            } else {
+                // Remove this one member box from the methods list
+                MemberBox[] methods = method.methods;
+                // Create a lookup for the ones to remove
+                HashMap<MemberBox, MemberBox> lookup = new HashMap<MemberBox, MemberBox>();
+                for (MemberBox member : members)
+                    lookup.put(member, member);
+                MemberBox[] newMethods = new MemberBox[length];
+                for (int i = 0, j = 0; i < methods.length; i++) {
+                    MemberBox member = methods[i];
+                    if (!lookup.containsKey(member))
+                        newMethods[j++] = member;
+                }
+                method.methods = newMethods;
+            }
+        }
+    }
+
     private Constructor<?>[] getAccessibleConstructors()
     {
       // The JVM currently doesn't allow changing access on java.lang.Class
Index: src/org/mozilla/javascript/NativeJavaMethod.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaMethod.java,v
retrieving revision 1.66
diff -u -r1.66 NativeJavaMethod.java
--- src/org/mozilla/javascript/NativeJavaMethod.java	29 Sep 2009 15:05:45 -0000	1.66
+++ src/org/mozilla/javascript/NativeJavaMethod.java	7 Jan 2010 00:51:16 -0000
@@ -433,11 +433,11 @@
         if (firstBestFit < 0) {
             // Nothing was found
             return -1;
-        } else if (extraBestFitsCount == 0) {
+        } else /*if (extraBestFitsCount == 0)*/ {
             // single best fit
             return firstBestFit;
         }
-
+        /*
         // report remaining ambiguity
         StringBuffer buf = new StringBuffer();
         for (int j = -1; j != extraBestFitsCount; ++j) {
@@ -457,13 +457,14 @@
 
         if (methodsOrCtors[0].isMethod()) {
             throw Context.reportRuntimeError3(
-                "msg.constructor.ambiguous",
+                "msg.method.ambiguous",
                 memberName, scriptSignature(args), buf.toString());
         } else {
             throw Context.reportRuntimeError4(
-                "msg.method.ambiguous", memberClass,
+                "msg.constructor.ambiguous", memberClass,
                 memberName, scriptSignature(args), buf.toString());
         }
+        */
     }
 
     /** Types are equal */
Index: src/org/mozilla/javascript/Context.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Context.java,v
retrieving revision 1.282
diff -u -r1.282 Context.java
--- src/org/mozilla/javascript/Context.java	23 Dec 2009 21:47:43 -0000	1.282
+++ src/org/mozilla/javascript/Context.java	7 Jan 2010 00:51:11 -0000
@@ -2111,6 +2111,19 @@
         return wrapFactory;
     }
 
+    public final void setOperatorHandler(OperatorHandler operatorHandler)
+    {
+        if (sealed) onSealedMutation();
+        if (operatorHandler == null)
+            throw new IllegalArgumentException();
+        this.operatorHandler = operatorHandler;
+    }
+
+    public final OperatorHandler getOperatorHandler()
+    {
+        return operatorHandler;
+    }
+
     /**
      * Return the current debugger.
      * @return the debugger, or null if none is attached.
@@ -2635,6 +2648,7 @@
     private int optimizationLevel;
     private int maximumInterpreterStackDepth;
     private WrapFactory wrapFactory;
+    private OperatorHandler operatorHandler;
     Debugger debugger;
     private Object debuggerData;
     private int enterCount;
Index: src/org/mozilla/javascript/ScriptableObject.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v
retrieving revision 1.162
diff -u -r1.162 ScriptableObject.java
--- src/org/mozilla/javascript/ScriptableObject.java	27 Nov 2009 18:30:16 -0000	1.162
+++ src/org/mozilla/javascript/ScriptableObject.java	7 Jan 2010 00:51:21 -0000
@@ -2943,6 +2943,18 @@
             return null;
         } else if (value instanceof Wrapper) {
             return ((Wrapper) value).unwrap();
+        // Lehni: Convert NativeArray to Java Object Arrays
+        } else if (value instanceof NativeArray) {
+            NativeArray array = (NativeArray) value;
+            int length = (int) array.getLength();
+            Object[] list = new Object[length];
+            for (int i = 0; i < length; i++) {
+                Object obj = array.get(i, array);
+                if (obj instanceof Wrapper)
+                    obj = ((Wrapper) obj).unwrap();
+                list[i] = obj;
+            }
+            return list;
         } else {
             return value;
         }
Index: src/org/mozilla/javascript/WrapFactory.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/WrapFactory.java,v
retrieving revision 1.20
diff -u -r1.20 WrapFactory.java
--- src/org/mozilla/javascript/WrapFactory.java	13 Nov 2008 18:03:40 -0000	1.20
+++ src/org/mozilla/javascript/WrapFactory.java	7 Jan 2010 00:51:21 -0000
@@ -151,6 +151,32 @@
     }
 
     /**
+     * Same as NativeJavaObject CONVERSION_*, but to be used
+     * by WrapFactory#getConversionWeight
+     */
+    public static final byte CONVERSION_TRIVIAL      = 1;
+    public static final byte CONVERSION_NONTRIVIAL   = 0;
+    public static final byte CONVERSION_NONE         = 99;
+
+	public int getConversionWeight(Object from, Class<?> to, int defaultWeight) {
+        return defaultWeight;
+	}
+
+    public Object coerceType(Class<?> type, Object value) {
+    	return null;
+    }
+
+    public boolean shouldAddBean(Class<?> cls, boolean isStatic,
+            MemberBox getter, MemberBox setter) {
+        return true;
+    }
+
+    public boolean shouldRemoveGetterSetter(Class<?> cls, boolean isStatic,
+            MemberBox getter, MemberBox setter) {
+        return false;
+    }
+    
+    /**
      * Return <code>false</code> if result of Java method, which is instance of
      * <code>String</code>, <code>Number</code>, <code>Boolean</code> and
      * <code>Character</code>, should be used directly as JavaScript primitive
Index: src/org/mozilla/javascript/NativeJavaObject.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaObject.java,v
retrieving revision 1.89
diff -u -r1.89 NativeJavaObject.java
--- src/org/mozilla/javascript/NativeJavaObject.java	31 Aug 2009 14:04:22 -0000	1.89
+++ src/org/mozilla/javascript/NativeJavaObject.java	7 Jan 2010 00:51:16 -0000
@@ -42,10 +42,16 @@
 
 package org.mozilla.javascript;
 
-import java.io.*;
-import java.lang.reflect.*;
-import java.util.Map;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.lang.reflect.Array;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * This class reflects non-Array Java objects into the JavaScript environment.  It
@@ -364,9 +370,10 @@
             }
             else if (to.isPrimitive() && to != Boolean.TYPE) {
                 return (fromCode == JSTYPE_JAVA_ARRAY)
-                       ? CONVERSION_NONE : 2 + getSizeRank(to);
+                       ? CONVERSION_NONE : 3 + getSizeRank(to);
+            } else {
+                return Context.getContext().getWrapFactory().getConversionWeight(fromObj, to, CONVERSION_NONE);
             }
-            break;
 
         case JSTYPE_OBJECT:
             // Other objects takes #1-#3 spots
@@ -379,14 +386,28 @@
                     // This is a native array conversion to a java array
                     // Array conversions are all equal, and preferable to object
                     // and string conversion, per LC3.
-                    return 1;
+
+                    // Lehni:
+                    // Look at the first element in the array to determine
+                    // conversion weight further. While this approach is not
+                    // perfect, it is certainly better than simply returning 1.
+                    // The only case where this does not work is with arrays
+                    // containing null at that position, and arrays containing
+                    // different types.
+                    return getConversionWeight(
+                            ((NativeArray) fromObj).get(0, (Scriptable) fromObj),
+                            to.getComponentType());
                 }
             }
             else if (to == ScriptRuntime.ObjectClass) {
                 return 2;
             }
             else if (to == ScriptRuntime.StringClass) {
-                return 3;
+                // Lehni:
+                // Prefer conversion from NativeString to a java String
+                // over the above conversion to a object.
+                // (typeof obj == 'object', not 'string'!)
+                return fromObj instanceof NativeString ? 1 : 3;
             }
             else if (to == ScriptRuntime.DateClass) {
                 if (fromObj instanceof NativeDate) {
@@ -401,7 +422,7 @@
                         return 1;
                     }
                 }
-                return 11;
+                return Context.getContext().getWrapFactory().getConversionWeight(fromObj, to, 11);
             }
             else if (to.isPrimitive() && to != Boolean.TYPE) {
                 return 3 + getSizeRank(to);
@@ -409,7 +430,7 @@
             break;
         }
 
-        return CONVERSION_NONE;
+        return Context.getContext().getWrapFactory().getConversionWeight(fromObj, to, CONVERSION_NONE);
     }
 
     static int getSizeRank(Class<?> aType) {
@@ -497,9 +518,33 @@
         return coerceTypeImpl(type, value);
     }
 
+    static Object coerce(Class<?> type, Object value) {
+        Object obj = Context.getContext().getWrapFactory().coerceType(type, value);
+        // Allow Undefined.instance being coerced to null, but nothing else
+        if (obj == null && value != Undefined.instance) {
+            reportConversionError(value instanceof Wrapper ? ((Wrapper) value).unwrap() : value, type);
+        }
+        return obj;
+    }
+
+    private static final HashMap<Class<?>, Class<?>> primitiveToWrapper
+            = new HashMap<Class<?>, Class<?>>();
+    static {
+        primitiveToWrapper.put(Boolean.TYPE, Boolean.class);
+        primitiveToWrapper.put(Character.TYPE, Character.class);
+        primitiveToWrapper.put(Byte.TYPE, Byte.class);
+        primitiveToWrapper.put(Short.TYPE, Short.class);
+        primitiveToWrapper.put(Integer.TYPE, Integer.class);
+        primitiveToWrapper.put(Long.TYPE, Long.class);
+        primitiveToWrapper.put(Float.TYPE, Float.class);
+        primitiveToWrapper.put(Double.TYPE, Double.class);
+        primitiveToWrapper.put(Void.TYPE, Void.class);
+    }
+
     /**
      * Type-munging for field setting and method invocation.
      * Conforms to LC3 specification
+     * @param genericType 
      */
     static Object coerceTypeImpl(Class<?> type, Object value)
     {
@@ -507,6 +552,8 @@
             return value;
         }
 
+        Object original = value;
+
         switch (getJSTypeCode(value)) {
 
         case JSTYPE_NULL:
@@ -522,9 +569,8 @@
                 return "undefined";
             }
             else {
-                reportConversionError("undefined", type);
+            	return coerce(type, value);
             }
-            break;
 
         case JSTYPE_BOOLEAN:
             // Under LC3, only JS Booleans can be coerced into a Boolean value
@@ -537,9 +583,8 @@
                 return value.toString();
             }
             else {
-                reportConversionError(value, type);
+                return coerce(type, value);
             }
-            break;
 
         case JSTYPE_NUMBER:
             if (type == ScriptRuntime.StringClass) {
@@ -553,9 +598,8 @@
                 return coerceToNumber(type, value);
             }
             else {
-                reportConversionError(value, type);
+                return coerce(type, value);
             }
-            break;
 
         case JSTYPE_STRING:
             if (type == ScriptRuntime.StringClass || type.isInstance(value)) {
@@ -581,9 +625,8 @@
                 return coerceToNumber(type, value);
             }
             else {
-                reportConversionError(value, type);
+                return coerce(type, value);
             }
-            break;
 
         case JSTYPE_JAVA_CLASS:
             if (value instanceof Wrapper) {
@@ -598,18 +641,17 @@
                 return value.toString();
             }
             else {
-                reportConversionError(value, type);
+                return coerce(type, original);
             }
-            break;
 
         case JSTYPE_JAVA_OBJECT:
-        case JSTYPE_JAVA_ARRAY:              
+        case JSTYPE_JAVA_ARRAY:
             if (value instanceof Wrapper) {
               value = ((Wrapper)value).unwrap();
             }
             if (type.isPrimitive()) {
                 if (type == Boolean.TYPE) {
-                    reportConversionError(value, type);
+                    return coerce(type, original);
                 }
                 return coerceToNumber(type, value);
             }
@@ -622,11 +664,13 @@
                         return value;
                     }
                     else {
-                        reportConversionError(value, type);
+                        // We must be here because canConvert returned true
+                        // Give it a try. pass the wrapped value, to let the
+                        // wrap factory decide what to do with it.
+                        return coerce(type, original);
                     }
                 }
             }
-            break;
 
         case JSTYPE_OBJECT:
             if (type == ScriptRuntime.StringClass) {
@@ -634,7 +678,7 @@
             }
             else if (type.isPrimitive()) {
                 if (type == Boolean.TYPE) {
-                    reportConversionError(value, type);
+                    return coerce(type, value);
                 }
                 return coerceToNumber(type, value);
             }
@@ -652,26 +696,33 @@
                 // Make a new java array, and coerce the JS array components
                 // to the target (component) type.
                 NativeArray array = (NativeArray) value;
-                long length = array.getLength();
+                int length = (int) array.getLength();
                 Class<?> arrayType = type.getComponentType();
-                Object Result = Array.newInstance(arrayType, (int)length);
+                Object result = Array.newInstance(arrayType, length);
+                // Convert primitive types to their wrappers, since coerceType
+                // is returning primitive values as boxed objects as well.
+                if (arrayType.isPrimitive())
+                    arrayType = primitiveToWrapper.get(arrayType);
                 for (int i = 0 ; i < length ; ++i) {
                     try  {
-                        Array.set(Result, i, coerceType(arrayType,
-                                                        array.get(i, array)));
+                        Object entry = coerceTypeImpl(arrayType, array.get(i, array));
+                        if (entry == Undefined.instance)
+                            entry = null;
+                        if (entry == null || arrayType.isInstance(entry))
+                            Array.set(result, i, entry);
                     }
                     catch (EvaluatorException ee) {
                         reportConversionError(value, type);
                     }
                 }
 
-                return Result;
+                return result;
             }
             else if (value instanceof Wrapper) {
                 value = ((Wrapper)value).unwrap();
                 if (type.isInstance(value))
                     return value;
-                reportConversionError(value, type);
+                return coerce(type, original);
             }
             else if (type.isInterface() && value instanceof Callable) {
                 // Try to use function as implementation of Java interface.
@@ -693,15 +744,15 @@
                     Context cx = Context.getContext();
                     Object glue
                         = InterfaceAdapter.create(cx, type, (Callable)value);
-                    // Store for later retrival
+                    // Store for later retrieval
                     glue = so.associateValue(key, glue);
                     return glue;
                 }
-                reportConversionError(value, type);
-            } else {
-                reportConversionError(value, type);
+                return coerce(type, value);
+            }
+            else {
+                return coerce(type, value);
             }
-            break;
         }
 
         return value;
Index: src/org/mozilla/javascript/NativeJavaPackage.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaPackage.java,v
retrieving revision 1.45
diff -u -r1.45 NativeJavaPackage.java
--- src/org/mozilla/javascript/NativeJavaPackage.java	5 Nov 2008 21:37:23 -0000	1.45
+++ src/org/mozilla/javascript/NativeJavaPackage.java	7 Jan 2010 00:51:16 -0000
@@ -60,7 +60,7 @@
 {
     static final long serialVersionUID = 7445054382212031523L;
 
-    NativeJavaPackage(boolean internalUsage, String packageName,
+    public NativeJavaPackage(boolean internalUsage, String packageName,
                       ClassLoader classLoader)
     {
         this.packageName = packageName;
@@ -137,7 +137,7 @@
         }
     }
 
-    synchronized Object getPkgProperty(String name, Scriptable start,
+    public synchronized Object getPkgProperty(String name, Scriptable start,
                                        boolean createPkg)
     {
         Object cached = super.get(name, start);
Index: src/org/mozilla/javascript/Interpreter.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java,v
retrieving revision 1.357
diff -u -r1.357 Interpreter.java
--- src/org/mozilla/javascript/Interpreter.java	21 Sep 2009 13:32:33 -0000	1.357
+++ src/org/mozilla/javascript/Interpreter.java	7 Jan 2010 00:51:14 -0000
@@ -1069,65 +1069,6 @@
         throwable = stack[indexReg];
         break withoutExceptions;
     }
-    case Token.GE :
-    case Token.LE :
-    case Token.GT :
-    case Token.LT : {
-        --stackTop;
-        Object rhs = stack[stackTop + 1];
-        Object lhs = stack[stackTop];
-        boolean valBln;
-      object_compare:
-        {
-          number_compare:
-            {
-                double rDbl, lDbl;
-                if (rhs == DBL_MRK) {
-                    rDbl = sDbl[stackTop + 1];
-                    lDbl = stack_double(frame, stackTop);
-                } else if (lhs == DBL_MRK) {
-                    rDbl = ScriptRuntime.toNumber(rhs);
-                    lDbl = sDbl[stackTop];
-                } else {
-                    break number_compare;
-                }
-                switch (op) {
-                  case Token.GE:
-                    valBln = (lDbl >= rDbl);
-                    break object_compare;
-                  case Token.LE:
-                    valBln = (lDbl <= rDbl);
-                    break object_compare;
-                  case Token.GT:
-                    valBln = (lDbl > rDbl);
-                    break object_compare;
-                  case Token.LT:
-                    valBln = (lDbl < rDbl);
-                    break object_compare;
-                  default:
-                    throw Kit.codeBug();
-                }
-            }
-            switch (op) {
-              case Token.GE:
-                valBln = ScriptRuntime.cmp_LE(rhs, lhs);
-                break;
-              case Token.LE:
-                valBln = ScriptRuntime.cmp_LE(lhs, rhs);
-                break;
-              case Token.GT:
-                valBln = ScriptRuntime.cmp_LT(rhs, lhs);
-                break;
-              case Token.LT:
-                valBln = ScriptRuntime.cmp_LT(lhs, rhs);
-                break;
-              default:
-                throw Kit.codeBug();
-            }
-        }
-        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
-        continue Loop;
-    }
     case Token.IN :
     case Token.INSTANCEOF : {
         Object rhs = stack[stackTop];
@@ -1144,37 +1085,6 @@
         stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
         continue Loop;
     }
-    case Token.EQ :
-    case Token.NE : {
-        --stackTop;
-        boolean valBln;
-        Object rhs = stack[stackTop + 1];
-        Object lhs = stack[stackTop];
-        if (rhs == DBL_MRK) {
-            if (lhs == DBL_MRK) {
-                valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
-            } else {
-                valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
-            }
-        } else {
-            if (lhs == DBL_MRK) {
-                valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
-            } else {
-                valBln = ScriptRuntime.eq(lhs, rhs);
-            }
-        }
-        valBln ^= (op == Token.NE);
-        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
-        continue Loop;
-    }
-    case Token.SHEQ :
-    case Token.SHNE : {
-        --stackTop;
-        boolean valBln = shallowEquals(stack, sDbl, stackTop);
-        valBln ^= (op == Token.SHNE);
-        stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
-        continue Loop;
-    }
     case Token.IFNE :
         if (stack_boolean(frame, stackTop--)) {
             frame.pc += 2;
@@ -1315,45 +1225,26 @@
         sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;
         continue Loop;
     }
-    case Token.NEG :
-    case Token.POS : {
-        double rDbl = stack_double(frame, stackTop);
-        stack[stackTop] = DBL_MRK;
-        if (op == Token.NEG) {
-            rDbl = -rDbl;
-        }
-        sDbl[stackTop] = rDbl;
-        continue Loop;
-    }
+    case Token.EQ :
+    case Token.NE :
+    case Token.SHEQ :
+    case Token.SHNE :
+    case Token.GE :
+    case Token.LE :
+    case Token.GT :
+    case Token.LT :
     case Token.ADD :
-        --stackTop;
-        do_add(stack, sDbl, stackTop, cx);
-        continue Loop;
     case Token.SUB :
     case Token.MUL :
     case Token.DIV :
-    case Token.MOD : {
-        double rDbl = stack_double(frame, stackTop);
+    case Token.MOD :
         --stackTop;
-        double lDbl = stack_double(frame, stackTop);
-        stack[stackTop] = DBL_MRK;
-        switch (op) {
-          case Token.SUB:
-            lDbl -= rDbl;
-            break;
-          case Token.MUL:
-            lDbl *= rDbl;
-            break;
-          case Token.DIV:
-            lDbl /= rDbl;
-            break;
-          case Token.MOD:
-            lDbl %= rDbl;
-            break;
-        }
-        sDbl[stackTop] = lDbl;
+        do_operator(op, stack, sDbl, stackTop, cx, frame.scope);
+        continue Loop;
+    case Token.NEG :
+    case Token.POS :
+        do_sign_operator(op, stack, sDbl, stackTop, cx, frame.scope);
         continue Loop;
-    }
     case Token.NOT :
         stack[stackTop] = ScriptRuntime.wrapBoolean(
                               !stack_boolean(frame, stackTop));
@@ -3015,71 +2906,201 @@
         }
     }
 
-    private static void do_add(Object[] stack, double[] sDbl, int stackTop,
-                              Context cx)
-    {
+    private static void do_operator(int operator, Object[] stack, double[] sDbl,
+            int stackTop, Context cx, Scriptable scope) {
         Object rhs = stack[stackTop + 1];
         Object lhs = stack[stackTop];
-        double d;
-        boolean leftRightOrder;
+        boolean lhsIsDouble, rhsIsDouble;
+        double lhsDouble, rhsDouble;
+        Number lhsNumber, rhsNumber;
+        if (lhs == UniqueTag.DOUBLE_MARK) {
+            lhsIsDouble = true;
+            lhsNumber = null;
+            lhsDouble = sDbl[stackTop];
+        } else if (lhs instanceof Number) {
+            lhsIsDouble = true;
+            lhsNumber = (Number) lhs;
+            lhsDouble = 0; // prevent compilation error
+        } else {
+            lhsIsDouble = false;
+            lhsNumber = null;
+            lhsDouble = 0; // prevent compilation error
+        }
         if (rhs == UniqueTag.DOUBLE_MARK) {
-            d = sDbl[stackTop + 1];
-            if (lhs == UniqueTag.DOUBLE_MARK) {
-                sDbl[stackTop] += d;
-                return;
-            }
-            leftRightOrder = true;
-            // fallthrough to object + number code
-        } else if (lhs == UniqueTag.DOUBLE_MARK) {
-            d = sDbl[stackTop];
-            lhs = rhs;
-            leftRightOrder = false;
-            // fallthrough to object + number code
-        } else {
-            if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
-                stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
-            } else if (lhs instanceof String) {
-                String lstr = (String)lhs;
-                String rstr = ScriptRuntime.toString(rhs);
-                stack[stackTop] = lstr.concat(rstr);
-            } else if (rhs instanceof String) {
-                String lstr = ScriptRuntime.toString(lhs);
-                String rstr = (String)rhs;
-                stack[stackTop] = lstr.concat(rstr);
-            } else {
-                double lDbl = (lhs instanceof Number)
-                    ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
-                double rDbl = (rhs instanceof Number)
-                    ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
-                stack[stackTop] = UniqueTag.DOUBLE_MARK;
-                sDbl[stackTop] = lDbl + rDbl;
+            rhsIsDouble = true;
+            rhsNumber = null;
+            rhsDouble = sDbl[stackTop + 1];
+        } else if (rhs instanceof Number) {
+            rhsIsDouble = true;
+            rhsNumber = (Number) rhs;
+            rhsDouble = 0; // prevent compilation error
+        } else {
+            rhsIsDouble = false;
+            rhsNumber = null;
+            rhsDouble = 0; // prevent compilation error
+        }
+        if (lhsIsDouble && rhsIsDouble) {
+            if (lhsNumber != null)
+                lhsDouble = lhsNumber.doubleValue();
+            if (rhsNumber != null)
+                rhsDouble = rhsNumber.doubleValue();
+            switch (operator) {
+                case Token.ADD:
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = lhsDouble + rhsDouble;
+                    break;
+                case Token.SUB:
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = lhsDouble - rhsDouble;
+                    break;
+                case Token.MUL:
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = lhsDouble * rhsDouble;
+                    break;
+                case Token.DIV:
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = lhsDouble / rhsDouble;
+                    break;
+                case Token.MOD:
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = lhsDouble % rhsDouble;
+                    break;
+                case Token.EQ:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.eqNumber(lhsDouble, rhsDouble));
+                    break;
+                case Token.NE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(!ScriptRuntime.eqNumber(lhsDouble, rhsDouble));
+                    break;
+                case Token.SHEQ:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble == rhsDouble);
+                    break;
+                case Token.SHNE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble != rhsDouble);
+                    break;
+                case Token.GE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble >= rhsDouble);
+                    break;
+                case Token.LE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble <= rhsDouble);
+                    break;
+                case Token.GT:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble > rhsDouble);
+                    break;
+                case Token.LT:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble < rhsDouble);
+                    break;
+                default:
+                    throw Kit.codeBug();
             }
             return;
+        } else {
+            if (lhsIsDouble && lhsNumber == null)
+                lhs = ScriptRuntime.wrapNumber(lhsDouble);
+            if (rhsIsDouble && rhsNumber == null)
+                rhs = ScriptRuntime.wrapNumber(rhsDouble);
+        }
+        // Try handler now, if set:
+        OperatorHandler handler = cx.getOperatorHandler();
+        Object result = handler != null
+            ? handler.handleOperator(cx, scope, operator, lhs, rhs)
+            : null;
+        if (result == null) { // default handling:
+            switch (operator) {
+                case Token.ADD:
+                    result = ScriptRuntime.add(lhs, rhs, cx);
+                    break;
+                case Token.SUB :
+                case Token.MUL :
+                case Token.DIV :
+                case Token.MOD: {
+                    lhsDouble = ScriptRuntime.toNumber(lhs);
+                    rhsDouble = ScriptRuntime.toNumber(rhs);
+                    switch (operator) {
+                        case Token.SUB:
+                            lhsDouble -= rhsDouble;
+                            break;
+                        case Token.MUL:
+                            lhsDouble *= rhsDouble;
+                            break;
+                        case Token.DIV:
+                            lhsDouble /= rhsDouble;
+                            break;
+                        case Token.MOD:
+                            lhsDouble %= rhsDouble;
+                            break;
+                    }
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = lhsDouble;
+                    break;
+                }
+                case Token.EQ:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.eq(lhs, rhs));
+                    break;
+                case Token.NE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(!ScriptRuntime.eq(lhs, rhs));
+                    break;
+                case Token.SHEQ:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.shallowEq(lhs, rhs));
+                    break;
+                case Token.SHNE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(!ScriptRuntime.shallowEq(lhs, rhs));
+                    break;
+                case Token.GE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LE(rhs, lhs));
+                    break;
+                case Token.LE:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LE(lhs, rhs));
+                    break;
+                case Token.GT:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LT(rhs, lhs));
+                    break;
+                case Token.LT:
+                    stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LT(lhs, rhs));
+                    break;
+                default:
+                    // Unsupported arithmetics -> NaN
+                    stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                    sDbl[stackTop] = Double.NaN;
+            }
         }
-
-        // handle object(lhs) + number(d) code
-        if (lhs instanceof Scriptable) {
-            rhs = ScriptRuntime.wrapNumber(d);
-            if (!leftRightOrder) {
-                Object tmp = lhs;
-                lhs = rhs;
-                rhs = tmp;
-            }
-            stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
-        } else if (lhs instanceof String) {
-            String lstr = (String)lhs;
-            String rstr = ScriptRuntime.toString(d);
-            if (leftRightOrder) {
-                stack[stackTop] = lstr.concat(rstr);
+        if (result != null) {
+            if (result instanceof Double) {
+                stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                sDbl[stackTop] = ((Double) result).doubleValue();
             } else {
-                stack[stackTop] = rstr.concat(lstr);
+                stack[stackTop] = result;
             }
+        }
+    }
+
+    private static void do_sign_operator(int operator, Object[] stack, double[] sDbl,
+            int stackTop, Context cx, Scriptable scope) {
+        Object rhs = stack[stackTop];
+        double rDbl;
+        if (rhs == UniqueTag.DOUBLE_MARK) {
+            rDbl = sDbl[stackTop];
         } else {
-            double lDbl = (lhs instanceof Number)
-                ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
-            stack[stackTop] = UniqueTag.DOUBLE_MARK;
-            sDbl[stackTop] = lDbl + d;
+            OperatorHandler handler;
+            if (rhs instanceof Number || (handler = cx.getOperatorHandler()) == null) {
+                rDbl = ScriptRuntime.toNumber(rhs); 
+            } else {
+                Object result = handler.handleSignOperator(cx, scope, operator, rhs);
+                if (result == null) {
+                    rDbl = ScriptRuntime.toNumber(rhs); 
+                } else {
+                    if (result instanceof Double) {
+                        stack[stackTop] = UniqueTag.DOUBLE_MARK;
+                        sDbl[stackTop] = ((Double) result).doubleValue();
+                    } else {
+                        stack[stackTop] = result;
+                    }
+                    return;
+                }
+            }
         }
+        // If we're still here, perform  double sign operator
+        stack[stackTop] = UniqueTag.DOUBLE_MARK;
+        sDbl[stackTop] = operator == Token.NEG ? -rDbl : rDbl;
     }
 
     private static Object[] getArgsArray(Object[] stack, double[] sDbl,
Index: src/org/mozilla/javascript/NativeJavaTopPackage.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaTopPackage.java,v
retrieving revision 1.22
diff -u -r1.22 NativeJavaTopPackage.java
--- src/org/mozilla/javascript/NativeJavaTopPackage.java	5 Apr 2009 09:09:42 -0000	1.22
+++ src/org/mozilla/javascript/NativeJavaTopPackage.java	7 Jan 2010 00:51:16 -0000
@@ -71,7 +71,7 @@
             {"javax", "swing"}
     };
 
-    NativeJavaTopPackage(ClassLoader loader)
+    public NativeJavaTopPackage(ClassLoader loader)
     {
         super(true, "", loader);
     }
Index: src/org/mozilla/javascript/IRFactory.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/IRFactory.java,v
retrieving revision 1.128
diff -u -r1.128 IRFactory.java
--- src/org/mozilla/javascript/IRFactory.java	9 Oct 2009 17:27:16 -0000	1.128
+++ src/org/mozilla/javascript/IRFactory.java	7 Jan 2010 00:51:12 -0000
@@ -1950,7 +1950,7 @@
             } else if (right.type == Token.NUMBER) {
                 if (right.getDouble() == 1.0) {
                     //second 1: x * 1 -> +x
-                    // can not make simply x because x - 0 must be number
+                    // not simply x to force number conversion
                     return new Node(Token.POS, left);
                 }
             }
@@ -1967,7 +1967,7 @@
                     return left;
                } else if (rd == 1.0) {
                     // second 1: x/1 -> +x
-                    // not simply x to force number convertion
+                    // not simply x to force number conversion
                     return new Node(Token.POS, left);
                 }
             }
Index: src/org/mozilla/javascript/NativeJavaClass.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaClass.java,v
retrieving revision 1.55
diff -u -r1.55 NativeJavaClass.java
--- src/org/mozilla/javascript/NativeJavaClass.java	5 Nov 2008 21:37:22 -0000	1.55
+++ src/org/mozilla/javascript/NativeJavaClass.java	7 Jan 2010 00:51:15 -0000
@@ -181,6 +181,12 @@
         return construct(cx, scope, args);
     }
 
+    protected MemberBox findConstructor(Context cx, Object[] args)
+    {
+        int index = NativeJavaMethod.findFunction(cx, members.ctors, args);
+        return index >= 0 ? members.ctors[index] : null;
+    }
+
     public Scriptable construct(Context cx, Scriptable scope, Object[] args)
     {
         Class<?> classObject = getClassObject();
@@ -188,16 +194,15 @@
         if (! (Modifier.isInterface(modifiers) ||
                Modifier.isAbstract(modifiers)))
         {
-            MemberBox[] ctors = members.ctors;
-            int index = NativeJavaMethod.findFunction(cx, ctors, args);
-            if (index < 0) {
+            MemberBox ctor = findConstructor(cx, args);
+            if (ctor == null) {
                 String sig = NativeJavaMethod.scriptSignature(args);
                 throw Context.reportRuntimeError2(
                     "msg.no.java.ctor", classObject.getName(), sig);
             }
 
             // Found the constructor, so try invoking it.
-            return constructSpecific(cx, scope, args, ctors[index]);
+            return constructSpecific(cx, scope, args, ctor);
         } else {
             Scriptable topLevel = ScriptableObject.getTopLevelScope(this);
             String msg = "";
Index: src/org/mozilla/javascript/OperatorHandler.java
===================================================================
RCS file: src/org/mozilla/javascript/OperatorHandler.java
diff -N src/org/mozilla/javascript/OperatorHandler.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/org/mozilla/javascript/OperatorHandler.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,6 @@
+package org.mozilla.javascript;
+
+public interface OperatorHandler {
+    public Object handleOperator(Context cx, Scriptable scope, int operator, Object lhs, Object rhs);
+    public Object handleSignOperator(Context cx, Scriptable scope, int operator, Object rhs);
+}
