Index: org/mozilla/javascript/Context.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Context.java,v
retrieving revision 1.268
diff -r1.268 Context.java
1969a1970,1982
>     public final void setOperatorHandler(OperatorHandler operatorHandler)
>     {
>         if (sealed) onSealedMutation();
>         if (operatorHandler == null)
>             throw new IllegalArgumentException();
>         this.operatorHandler = operatorHandler;
>     }
> 
>     public final OperatorHandler getOperatorHandler()
>     {
>         return operatorHandler;
>     }
> 
2489a2503
>     private OperatorHandler operatorHandler;
Index: org/mozilla/javascript/NativeJavaTopPackage.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaTopPackage.java,v
retrieving revision 1.19
diff -r1.19 NativeJavaTopPackage.java
77c77
<     NativeJavaTopPackage(ClassLoader loader)
---
>     public NativeJavaTopPackage(ClassLoader loader)
Index: org/mozilla/javascript/NativeJavaPackage.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaPackage.java,v
retrieving revision 1.43
diff -r1.43 NativeJavaPackage.java
63c63
<     NativeJavaPackage(boolean internalUsage, String packageName,
---
>     public NativeJavaPackage(boolean internalUsage, String packageName,
149c149
<     synchronized Object getPkgProperty(String name, Scriptable start,
---
>     public synchronized Object getPkgProperty(String name, Scriptable start,
Index: org/mozilla/javascript/Interpreter.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java,v
retrieving revision 1.344
diff -r1.344 Interpreter.java
2697,2755d2696
<     case Token.GE :
<     case Token.LE :
<     case Token.GT :
<     case Token.LT : {
<         --stackTop;
<         Object rhs = stack[stackTop + 1];
<         Object lhs = stack[stackTop];
<         boolean valBln;
<       object_compare:
<         {
<           number_compare:
<             {
<                 double rDbl, lDbl;
<                 if (rhs == DBL_MRK) {
<                     rDbl = sDbl[stackTop + 1];
<                     lDbl = stack_double(frame, stackTop);
<                 } else if (lhs == DBL_MRK) {
<                     rDbl = ScriptRuntime.toNumber(rhs);
<                     lDbl = sDbl[stackTop];
<                 } else {
<                     break number_compare;
<                 }
<                 switch (op) {
<                   case Token.GE:
<                     valBln = (lDbl >= rDbl);
<                     break object_compare;
<                   case Token.LE:
<                     valBln = (lDbl <= rDbl);
<                     break object_compare;
<                   case Token.GT:
<                     valBln = (lDbl > rDbl);
<                     break object_compare;
<                   case Token.LT:
<                     valBln = (lDbl < rDbl);
<                     break object_compare;
<                   default:
<                     throw Kit.codeBug();
<                 }
<             }
<             switch (op) {
<               case Token.GE:
<                 valBln = ScriptRuntime.cmp_LE(rhs, lhs);
<                 break;
<               case Token.LE:
<                 valBln = ScriptRuntime.cmp_LE(lhs, rhs);
<                 break;
<               case Token.GT:
<                 valBln = ScriptRuntime.cmp_LT(rhs, lhs);
<                 break;
<               case Token.LT:
<                 valBln = ScriptRuntime.cmp_LT(lhs, rhs);
<                 break;
<               default:
<                 throw Kit.codeBug();
<             }
<         }
<         stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
<         continue Loop;
<     }
2772,2832d2712
<     case Token.EQ :
<     case Token.NE : {
<         --stackTop;
<         boolean valBln;
<         Object rhs = stack[stackTop + 1];
<         Object lhs = stack[stackTop];
<         if (rhs == DBL_MRK) {
<             if (lhs == DBL_MRK) {
<                 valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
<             } else {
<                 valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
<             }
<         } else {
<             if (lhs == DBL_MRK) {
<                 valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
<             } else {
<                 valBln = ScriptRuntime.eq(lhs, rhs);
<             }
<         }
<         valBln ^= (op == Token.NE);
<         stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
<         continue Loop;
<     }
<     case Token.SHEQ :
<     case Token.SHNE : {
<         --stackTop;
<         Object rhs = stack[stackTop + 1];
<         Object lhs = stack[stackTop];
<         boolean valBln;
<       shallow_compare: {
<             double rdbl, ldbl;
<             if (rhs == DBL_MRK) {
<                 rdbl = sDbl[stackTop + 1];
<                 if (lhs == DBL_MRK) {
<                     ldbl = sDbl[stackTop];
<                 } else if (lhs instanceof Number) {
<                     ldbl = ((Number)lhs).doubleValue();
<                 } else {
<                     valBln = false;
<                     break shallow_compare;
<                 }
<             } else if (lhs == DBL_MRK) {
<                 ldbl = sDbl[stackTop];
<                 if (rhs == DBL_MRK) {
<                     rdbl = sDbl[stackTop + 1];
<                 } else if (rhs instanceof Number) {
<                     rdbl = ((Number)rhs).doubleValue();
<                 } else {
<                     valBln = false;
<                     break shallow_compare;
<                 }
<             } else {
<                 valBln = ScriptRuntime.shallowEq(lhs, rhs);
<                 break shallow_compare;
<             }
<             valBln = (ldbl == rdbl);
<         }
<         valBln ^= (op == Token.SHNE);
<         stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
<         continue Loop;
<     }
2973,2982c2853,2860
<     case Token.NEG :
<     case Token.POS : {
<         double rDbl = stack_double(frame, stackTop);
<         stack[stackTop] = DBL_MRK;
<         if (op == Token.NEG) {
<             rDbl = -rDbl;
<         }
<         sDbl[stackTop] = rDbl;
<         continue Loop;
<     }
---
>     case Token.EQ :
>     case Token.NE :
>     case Token.SHEQ :
>     case Token.SHNE :
>     case Token.GE :
>     case Token.LE :
>     case Token.GT :
>     case Token.LT :
2984,2986d2861
<         --stackTop;
<         do_add(stack, sDbl, stackTop, cx);
<         continue Loop;
2990,2991c2865
<     case Token.MOD : {
<         double rDbl = stack_double(frame, stackTop);
---
>     case Token.MOD :
2993,3009c2867,2871
<         double lDbl = stack_double(frame, stackTop);
<         stack[stackTop] = DBL_MRK;
<         switch (op) {
<           case Token.SUB:
<             lDbl -= rDbl;
<             break;
<           case Token.MUL:
<             lDbl *= rDbl;
<             break;
<           case Token.DIV:
<             lDbl /= rDbl;
<             break;
<           case Token.MOD:
<             lDbl %= rDbl;
<             break;
<         }
<         sDbl[stackTop] = lDbl;
---
>         do_operator(op, stack, sDbl, stackTop, cx, frame.scope);
>         continue Loop;
>     case Token.NEG :
>     case Token.POS : {
>         do_sign_operator(op, stack, sDbl, stackTop, cx, frame.scope);
4550,4552c4412,4413
<     private static void do_add(Object[] stack, double[] sDbl, int stackTop,
<                               Context cx)
<     {
---
>     private static void do_operator(int operator, Object[] stack, double[] sDbl,
>             int stackTop, Context cx, Scriptable scope) {
4555,4556c4416,4431
<         double d;
<         boolean leftRightOrder;
---
>         boolean lhsIsDouble, rhsIsDouble;
>         double lhsDouble, rhsDouble;
>         Number lhsNumber, rhsNumber;
>         if (lhs == UniqueTag.DOUBLE_MARK) {
>             lhsIsDouble = true;
>             lhsNumber = null;
>             lhsDouble = sDbl[stackTop];
>         } else if (lhs instanceof Number) {
>             lhsIsDouble = true;
>             lhsNumber = (Number) lhs;
>             lhsDouble = 0; // prevent compilation error
>         } else {
>             lhsIsDouble = false;
>             lhsNumber = null;
>             lhsDouble = 0; // prevent compilation error
>         }
4558,4587c4433,4496
<             d = sDbl[stackTop + 1];
<             if (lhs == UniqueTag.DOUBLE_MARK) {
<                 sDbl[stackTop] += d;
<                 return;
<             }
<             leftRightOrder = true;
<             // fallthrough to object + number code
<         } else if (lhs == UniqueTag.DOUBLE_MARK) {
<             d = sDbl[stackTop];
<             lhs = rhs;
<             leftRightOrder = false;
<             // fallthrough to object + number code
<         } else {
<             if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
<                 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
<             } else if (lhs instanceof String) {
<                 String lstr = (String)lhs;
<                 String rstr = ScriptRuntime.toString(rhs);
<                 stack[stackTop] = lstr.concat(rstr);
<             } else if (rhs instanceof String) {
<                 String lstr = ScriptRuntime.toString(lhs);
<                 String rstr = (String)rhs;
<                 stack[stackTop] = lstr.concat(rstr);
<             } else {
<                 double lDbl = (lhs instanceof Number)
<                     ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
<                 double rDbl = (rhs instanceof Number)
<                     ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
<                 stack[stackTop] = UniqueTag.DOUBLE_MARK;
<                 sDbl[stackTop] = lDbl + rDbl;
---
>             rhsIsDouble = true;
>             rhsNumber = null;
>             rhsDouble = sDbl[stackTop + 1];
>         } else if (rhs instanceof Number) {
>             rhsIsDouble = true;
>             rhsNumber = (Number) rhs;
>             rhsDouble = 0; // prevent compilation error
>         } else {
>             rhsIsDouble = false;
>             rhsNumber = null;
>             rhsDouble = 0; // prevent compilation error
>         }
>         if (lhsIsDouble && rhsIsDouble) {
>             if (lhsNumber != null)
>                 lhsDouble = lhsNumber.doubleValue();
>             if (rhsNumber != null)
>                 rhsDouble = rhsNumber.doubleValue();
>             switch (operator) {
>                 case Token.ADD:
>                     stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                     sDbl[stackTop] = lhsDouble + rhsDouble;
>                     break;
>                 case Token.SUB:
>                     stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                     sDbl[stackTop] = lhsDouble - rhsDouble;
>                     break;
>                 case Token.MUL:
>                     stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                     sDbl[stackTop] = lhsDouble * rhsDouble;
>                     break;
>                 case Token.DIV:
>                     stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                     sDbl[stackTop] = lhsDouble / rhsDouble;
>                     break;
>                 case Token.MOD:
>                     stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                     sDbl[stackTop] = lhsDouble % rhsDouble;
>                     break;
>                 case Token.EQ:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.eqNumber(lhsDouble, rhsDouble));
>                     break;
>                 case Token.NE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(!ScriptRuntime.eqNumber(lhsDouble, rhsDouble));
>                     break;
>                 case Token.SHEQ:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble == rhsDouble);
>                     break;
>                 case Token.SHNE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble != rhsDouble);
>                     break;
>                 case Token.GE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble >= rhsDouble);
>                     break;
>                 case Token.LE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble <= rhsDouble);
>                     break;
>                 case Token.GT:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble > rhsDouble);
>                     break;
>                 case Token.LT:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(lhsDouble < rhsDouble);
>                     break;
>                 default:
>                     throw Kit.codeBug();
4589a4499,4543
>         } else {
>             if (lhsIsDouble && lhsNumber == null)
>                 lhs = ScriptRuntime.wrapNumber(lhsDouble);
>             if (rhsIsDouble && rhsNumber == null)
>                 rhs = ScriptRuntime.wrapNumber(rhsDouble);
>         }
>         // Try handler now, if set:
>         OperatorHandler handler = cx.getOperatorHandler();
>         Object result = handler != null
>             ? handler.handleOperator(cx, scope, operator, lhs, rhs)
>             : null;
>         if (result == null) { // default handling:
>             switch (operator) {
>                 case Token.ADD:
>                     result = ScriptRuntime.add(lhs, rhs, cx);
>                     break;
>                 case Token.EQ:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.eq(lhs, rhs));
>                     break;
>                 case Token.NE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(!ScriptRuntime.eq(lhs, rhs));
>                     break;
>                 case Token.SHEQ:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.shallowEq(lhs, rhs));
>                     break;
>                 case Token.SHNE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(!ScriptRuntime.shallowEq(lhs, rhs));
>                     break;
>                 case Token.GE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LE(rhs, lhs));
>                     break;
>                 case Token.LE:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LE(lhs, rhs));
>                     break;
>                 case Token.GT:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LT(rhs, lhs));
>                     break;
>                 case Token.LT:
>                     stack[stackTop] = ScriptRuntime.wrapBoolean(ScriptRuntime.cmp_LT(lhs, rhs));
>                     break;
>                 default:
>                     // Unsupported arithmetics -> NaN
>                     stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                     sDbl[stackTop] = Double.NaN;
>             }
4591,4605c4545,4548
< 
<         // handle object(lhs) + number(d) code
<         if (lhs instanceof Scriptable) {
<             rhs = ScriptRuntime.wrapNumber(d);
<             if (!leftRightOrder) {
<                 Object tmp = lhs;
<                 lhs = rhs;
<                 rhs = tmp;
<             }
<             stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
<         } else if (lhs instanceof String) {
<             String lstr = (String)lhs;
<             String rstr = ScriptRuntime.toString(d);
<             if (leftRightOrder) {
<                 stack[stackTop] = lstr.concat(rstr);
---
>         if (result != null) {
>             if (result instanceof Double) {
>                 stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                 sDbl[stackTop] = ((Double) result).doubleValue();
4607c4550
<                 stack[stackTop] = rstr.concat(lstr);
---
>                 stack[stackTop] = result;
4608a4552,4560
>         }
>     }
> 
>     private static void do_sign_operator(int operator, Object[] stack, double[] sDbl,
>             int stackTop, Context cx, Scriptable scope) {
>         Object rhs = stack[stackTop];
>         double rDbl;
>         if (rhs == UniqueTag.DOUBLE_MARK) {
>             rDbl = sDbl[stackTop];
4610,4613c4562,4578
<             double lDbl = (lhs instanceof Number)
<                 ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
<             stack[stackTop] = UniqueTag.DOUBLE_MARK;
<             sDbl[stackTop] = lDbl + d;
---
>             OperatorHandler handler;
>             if (rhs instanceof Number || (handler = cx.getOperatorHandler()) == null) {
>                 rDbl = ScriptRuntime.toNumber(rhs); 
>             } else {
>                 Object result = handler.handleSignOperator(cx, scope, operator, rhs);
>                 if (result == null) {
>                     rDbl = ScriptRuntime.toNumber(rhs); 
>                 } else {
>                     if (result instanceof Double) {
>                         stack[stackTop] = UniqueTag.DOUBLE_MARK;
>                         sDbl[stackTop] = ((Double) result).doubleValue();
>                     } else {
>                         stack[stackTop] = result;
>                     }
>                     return;
>                 }
>             }
4614a4580,4582
>         // If we're still here, perform  double sign operator
>         stack[stackTop] = UniqueTag.DOUBLE_MARK;
>         sDbl[stackTop] = operator == Token.NEG ? -rDbl : rDbl;
Index: org/mozilla/javascript/WrapFactory.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/WrapFactory.java,v
retrieving revision 1.19
diff -r1.19 WrapFactory.java
153a154,169
>      * Same as NativeJavaObject CONVERSION_*, but to be used
>      * by WrapFactory#getConversionWeight
>      */
>     public static final byte CONVERSION_TRIVIAL      = 1;
>     public static final byte CONVERSION_NONTRIVIAL   = 0;
>     public static final byte CONVERSION_NONE         = 99;
> 
> 	public int getConversionWeight(Object from, Class to, int defaultWeight) {
>         return defaultWeight;
> 	}
> 
>     public Object coerceType(Class type, Object value) {
>     	return null;
>     }
> 
>     /**
182d197
< 
Index: org/mozilla/javascript/NativeJavaObject.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaObject.java,v
retrieving revision 1.84
diff -r1.84 NativeJavaObject.java
367a368,369
>             } else {
>                 return Context.getContext().getWrapFactory().getConversionWeight(fromObj, to, CONVERSION_NONE);
369d370
<             break;
380,382c381,392
<                     // Array conversions are all equal, and preferable to object
<                     // and string conversion, per LC3.
<                     return 1;
---
> 					// Array conversions are all equal, and preferable to object
> 					// and string conversion, per LC3.
> 
> 					// Look at the first element in the array to determine
> 					// conversion weight further. While this approach is not
> 					// perfect, it is certainly better than simply returning 1.
> 					// The only case where this does not work is with arrays
> 					// containing null at that position, and arrays containing
> 					// different types.
>                 	return getConversionWeight(
>                 			((NativeArray) fromObj).get(0, (Scriptable) fromObj),
>                 			to.getComponentType());
404c414
<                 return 11;
---
>                 return Context.getContext().getWrapFactory().getConversionWeight(fromObj, to, 11);
412c422
<         return CONVERSION_NONE;
---
>         return Context.getContext().getWrapFactory().getConversionWeight(fromObj, to, CONVERSION_NONE);
499a510,519
>     static Object coerce(Class type, Object value) {
>         Object obj = Context.getContext().getWrapFactory().coerceType(type, value);
>         if (obj == null) {
>             if (value == Undefined.instance)
>             	value = "undefined";
>             reportConversionError(value instanceof Wrapper ? ((Wrapper) value).unwrap() : value, type);
>         }
>         return obj;
>     }
> 
509a530,531
>         Object original = value;
> 
525c547
<                 reportConversionError("undefined", type);
---
>             	return coerce(type, value);
527d548
<             break;
540c561
<                 reportConversionError(value, type);
---
>                 return coerce(type, value);
542d562
<             break;
556c576
<                 reportConversionError(value, type);
---
>                 return coerce(type, value);
558d577
<             break;
584c603
<                 reportConversionError(value, type);
---
>                 return coerce(type, value);
586d604
<             break;
601c619
<                 reportConversionError(value, type);
---
>                 return coerce(type, original);
603d620
<             break;
606c623
<         case JSTYPE_JAVA_ARRAY:              
---
>         case JSTYPE_JAVA_ARRAY:
612c629
<                     reportConversionError(value, type);
---
>                     return coerce(type, original);
625c642,645
<                         reportConversionError(value, type);
---
>                         // We must be here because canConvert returned true
>                         // Give it a try. pass the wrapped value, to let the
>                         // wrap factory decide what to do with it.
>                         return coerce(type, original);
629d648
<             break;
637c656
<                     reportConversionError(value, type);
---
>                     return coerce(type, value);
674c693
<                 reportConversionError(value, type);
---
>                 return coerce(type, original);
696c715
<                     // Store for later retrival
---
>                     // Store for later retrieval
700,702c719,722
<                 reportConversionError(value, type);
<             } else {
<                 reportConversionError(value, type);
---
>                 return coerce(type, value);
>             }
>             else {
>                 return coerce(type, value);
704d723
<             break;
Index: org/mozilla/javascript/JavaMembers.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/JavaMembers.java,v
retrieving revision 1.76
diff -r1.76 JavaMembers.java
55c55
< class JavaMembers
---
> public class JavaMembers
57c57
<     JavaMembers(Scriptable scope, Class<?> cl)
---
>     public JavaMembers(Scriptable scope, Class<?> cl)
82c82
<     boolean has(String name, boolean isStatic)
---
>     public boolean has(String name, boolean isStatic)
92c92
<     Object get(Scriptable scope, String name, Object javaObject,
---
>     public Object get(Scriptable scope, String name, Object javaObject,
133c133
<     void put(Scriptable scope, String name, Object javaObject,
---
>     public void put(Scriptable scope, String name, Object javaObject,
198c198
<     Object[] getIds(boolean isStatic)
---
>     public Object[] getIds(boolean isStatic)
Index: org/mozilla/javascript/Token.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Token.java,v
retrieving revision 1.43
diff -r1.43 Token.java
44a45,46
> import java.io.IOException;
> 
433a436,472
> 
>     /**
>      * The token type.
>      */
>     public final int type;
> 
>     /**
>      * The string value for string tokens.
>      */
>     public final String string;
> 
>     /**
>      * The line number of the token.
>      */
>     public final int lineno;
> 
>     /**
>      * The line offset of the token.
>      */
>     public final int offset;
> 
>     /**
>      * The Token class is usually not instanciated when parsing a JavaScript
>      * resource. This constructor is only used by
>      * {@link org.mozilla.javascript.Parser#parseTokens(java.io.Reader, String, int)}
>      * to get information about lexical tokens.
>      * @param type the token type
>      * @param string the string value for string tokens
>      * @param lineno the line number of the token
>      * @param offset the line offset of the token
>      */
>     public Token(int type, String string, int lineno, int offset) {
>         this.type = type;
>         this.string = string;
>         this.lineno = lineno;
>         this.offset = offset;
>     }
Index: org/mozilla/javascript/MemberBox.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/MemberBox.java,v
retrieving revision 1.18
diff -r1.18 MemberBox.java
55c55
< final class MemberBox implements Serializable
---
> public final class MemberBox implements Serializable
65c65
<     MemberBox(Method method)
---
>     public MemberBox(Method method)
70c70
<     MemberBox(Constructor<?> constructor)
---
>     public MemberBox(Constructor<?> constructor)
89c89
<     Method method()
---
>     public Method method()
94c94
<     Constructor<?> ctor()
---
>     public Constructor<?> ctor()
99c99
<     Member member()
---
>     public Member member()
104c104
<     boolean isMethod()
---
>     public boolean isMethod()
109c109
<     boolean isCtor()
---
>     public boolean isCtor()
114c114
<     boolean isStatic()
---
>     public boolean isStatic()
119c119
<     String getName()
---
>     public String getName()
124c124
<     Class<?> getDeclaringClass()
---
>     public Class<?> getDeclaringClass()
129c129
<     String toJavaDeclaration()
---
>     public String toJavaDeclaration()
156c156
<     Object invoke(Object target, Object[] args)
---
>     public Object invoke(Object target, Object[] args)
180c180
<     Object newInstance(Object[] args)
---
>     public Object newInstance(Object[] args)
Index: org/mozilla/javascript/Parser.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Parser.java,v
retrieving revision 1.126
diff -r1.126 Parser.java
50a51,52
> import java.io.StringReader;
> import java.util.ArrayList;
324a327,376
>     /**
>      * Parse the given sourceReader into an array of {@link Token} objects.
>      * This can be useful for inspecting a JavaScript resource for other goals
>      * than compiling and evaluating it, as the tree generated by
>      * {@link #parse(java.io.Reader, String, int)} is missing a
>      * lot of information.
>      * @param sourceString a JavaScript string
>      * @param sourceURI the source name
>      * @param lineno the line number of the first line
>      * @return an array of {@link Token} objects
>      * @throws IOException if an I/O error was encountered
>      */
>     public Token[] parseTokens(String sourceString,
>                                String sourceURI, int lineno)
>         throws IOException
>     {
>         return parseTokens(new StringReader(sourceString),
>                            sourceURI, lineno);
>     }
> 
>     /**
>      * Parse the given sourceReader into an array of {@link Token} objects.
>      * This can be useful for inspecting a JavaScript resource for other goals
>      * than compiling and evaluating it, as the tree generated by
>      * {@link #parse(java.io.Reader, String, int)} is missing a
>      * lot of information.
>      * @param sourceReader the reader
>      * @param sourceURI the source name
>      * @param lineno the line number of the first line
>      * @return an array of {@link Token} objects
>      * @throws IOException if an I/O error was encountered
>      */
>     public Token[] parseTokens(Reader sourceReader,
>                                String sourceURI, int lineno)
>         throws IOException
>     {
>         this.sourceURI = sourceURI;
>         this.ts = new TokenStream(this, sourceReader, null, lineno);
>         ArrayList<Token> list = new ArrayList<Token>();
>         while (!ts.eof()) {
>             try {
>                 list.add(new Token(ts.getToken(), ts.getString(),
>                                    ts.getLineno(), ts.getOffset()));
>             } catch (EvaluatorException x) {
>                 // Regular expressions need special treatment by the parser - ignore.
>             }
>         }
>         return (Token[]) list.toArray(new Token[list.size()]);
>     }
> 
347c399
<      * Build a parse tree from the given sourceString.
---
>      * Build a parse tree from the given sourceReader.
Index: org/mozilla/javascript/NativeJavaClass.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeJavaClass.java,v
retrieving revision 1.54
diff -r1.54 NativeJavaClass.java
183a184,189
>     protected MemberBox findConstructor(Context cx, Object[] args)
>     {
>         int index = NativeJavaMethod.findFunction(cx, members.ctors, args);
>         return index >= 0 ? members.ctors[index] : null;
>     }
> 
191,193c197,198
<             MemberBox[] ctors = members.ctors;
<             int index = NativeJavaMethod.findFunction(cx, ctors, args);
<             if (index < 0) {
---
>             MemberBox ctor = findConstructor(cx, args);
>             if (ctor == null) {
200c205
<             return constructSpecific(cx, scope, args, ctors[index]);
---
>             return constructSpecific(cx, scope, args, ctor);
Index: org/mozilla/javascript/OperatorHandler.java
===================================================================
RCS file: org/mozilla/javascript/OperatorHandler.java
diff -N org/mozilla/javascript/OperatorHandler.java
0a1,6
> package org.mozilla.javascript;
> 
> public interface OperatorHandler {
>     public Object handleOperator(Context cx, Scriptable scope, int operator, Object lhs, Object rhs);
>     public Object handleSignOperator(Context cx, Scriptable scope, int operator, Object rhs);
> }
